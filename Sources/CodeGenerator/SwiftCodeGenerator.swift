import SchemaParser

protocol SwiftCodeConvertible {
    func toSwiftCode(indentedBy indentChars: String) -> SwiftCode
}

protocol LinesOfCodeConvertible: SwiftCodeConvertible {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode]
}

extension LinesOfCodeConvertible {
    func toSwiftCode(indentedBy indentChars: String = "    ") -> SwiftCode {
        let indentation = Indentation(chars: indentChars)
        let linesOfCode = toLinesOfCode(at: indentation)
        return linesOfCode.joined(separator: "\n")
    }
}

struct SwiftCodeGenerator {
    /// This method is used when only one Swift file is being generated.
    static func generateCode(for types: [SwiftCodeConvertible], _ clients: [SwiftClientClass]) -> String {
        return [
            preamble,
            "//",
            "// MARK: - SOAP Structures",
            "//",
            types.map { $0.toSwiftCode(indentedBy: "    ") }.joined(separator: "\n\n"),
            "",
            "//",
            "// MARK: - SOAP Client",
            "//",
            clients.map { $0.toSwiftCode(indentedBy: "    ") }.joined(separator: "\n\n"),
            ""].joined(separator: "\n")
    }

    private static let preamble = [
        "// This file was generated by Lark. https://github.com/Bouke/Lark",
        "",
        "import Foundation",
        "import LarkRuntime",
        ""].joined(separator: "\n")
}


// MARK: - Implementation

typealias SwiftCode = String
typealias LineOfCode = SwiftCode

struct Indentation {
    private let chars: String
    private let level: Int
    private let value: String

    init(chars: String, level: Int = 0) {
        precondition(level >= 0)
        self.chars = chars
        self.level = level
        self.value = String(repeating: chars, count: level)
    }

    func apply(toLineOfCode lineOfCode: LineOfCode) -> LineOfCode {
        return value + lineOfCode
    }

    func apply(toFirstLine firstLine: LineOfCode,
               nestedLines: [LineOfCode],
               andLastLine lastLine: LineOfCode) -> [LineOfCode] {
        return apply(
            toFirstLine: firstLine,
            nestedLines: { indentation in nestedLines.map { line in indentation.apply(toLineOfCode: line) } },
            andLastLine: lastLine)
    }

    func apply(toFirstLine firstLine: LineOfCode,
               nestedLines generateNestedLines: (Indentation) -> [LineOfCode],
               andLastLine lastLine: LineOfCode) -> [LineOfCode] {
        let first  = apply(toLineOfCode: firstLine)
        let middle = generateNestedLines(self.increased())
        let last   = apply(toLineOfCode: lastLine)
        return [first] + middle + [last]
    }

    private func increased() -> Indentation {
        return Indentation(chars: chars, level: level + 1)
    }
}


// MARK:- SOAP Types

extension SwiftTypeClass {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        let superType = superName ?? "XMLDeserializable"
        return indentation.apply(
            toFirstLine: "class \(name): \(superType) {",
            nestedLines:      linesOfCodeForMembers(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForMembers(at indentation: Indentation) -> [LineOfCode] {
        return linesOfCodeForProperties(at: indentation)
//            + ["init() { abort() }"].map(indentation.apply(toLineOfCode:))
            + deserializer(at: indentation)
//            + initializer.toLinesOfCode(at: indentation)
//            + failableInitializer.toLinesOfCode(at: indentation)
            + linesOfCodeForNestedClasses(at: indentation)
            + members.flatMap { $0.toLinesOfCode(at: indentation) }
    }

    private func deserializer(at indentation: Indentation) -> [LineOfCode] {
        let superInit: [LineOfCode] = superName.map { _ in ["try super.init(deserialize: element)"] } ?? []

        return indentation.apply(
            toFirstLine: "required init(deserialize element: XMLElement) throws {",
            nestedLines:
                properties.map { property in
                    let element = property.element.name
                    switch property.type {
                    case let .identifier(identifier):
                        return "self.\(property.name) = try \(identifier)(deserialize: element.elements(forLocalName: \"\(element.localName)\", uri: \"\(element.uri)\").first!)"
                    case let .optional(.identifier(identifier)):
                        return "self.\(property.name) = try element.elements(forLocalName: \"\(element.localName)\", uri: \"\(element.uri)\").first?.map(\(identifier).init(deserialize:))"
                    case let .array(.identifier(identifier)):
                        return "self.\(property.name) = try element.elements(forLocalName: \"\(element.localName)\", uri: \"\(element.uri)\").map(\(identifier).init(deserialize:))"
                    default:
                        fatalError("Type \(property.type) not supported")
                    }
                } + superInit,
            andLastLine: "}")
    }

    private func linesOfCodeForProperties(at indentation: Indentation) -> [LineOfCode] {
        return sortedProperties.map { property in
            let propertyCode = property.toLineOfCode()
            return indentation.apply(toLineOfCode: propertyCode)
        }
    }

    private var sortedProperties: [SwiftProperty] {
        return properties.sorted { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        }
    }

    private func linesOfCodeForNestedClasses(at indentation: Indentation) -> [LineOfCode] {
        return sortedNestedTypes.flatMap { $0.toLinesOfCode(at: indentation) }
    }

    private var sortedNestedTypes: [SwiftMetaType] {
        return nestedTypes.sorted(by: { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        })
    }
}

extension SwiftType {
    func toSwiftCode() -> SwiftCode {
        switch self {
        case let .identifier(name): return name
        case let .optional(type): return "\(type.toSwiftCode())?"
        case let .array(type): return "[\(type.toSwiftCode())]"
        }
    }
}

extension SwiftProperty {
    func toLineOfCode() -> LineOfCode {
        return "let \(name): \(type.toSwiftCode())"
    }
}

extension SwiftParameter {
    func toSwiftCode() -> SwiftCode {
        return "\(name): \(type.toSwiftCode())"
    }
}

extension SwiftEnum {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "enum \(name): \(rawType.toSwiftCode()) {",
            nestedLines:      linesOfCodeForCases(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForCases(at indentation: Indentation) -> [LineOfCode] {
        return sortedCases.map { (name, rawValue) in
            return indentation.apply(toLineOfCode: "case \(name) = \"\(rawValue)\"")
        }
    }

    private var sortedCases: [(String, String)] {
        return cases.sorted(by: { return $0.key < $1.key } )
    }
}

// MARK:- SOAP Client

extension SwiftClientClass {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "class \(name) {",
            nestedLines:      linesOfCodeForMembers(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForMembers(at indentation: Indentation) -> [LineOfCode] {
        return ["init() {", "}"].map(indentation.apply(toLineOfCode:))
            + methods.flatMap { $0.toLinesOfCode(at: indentation) }
    }
}

extension ServiceMethod: LinesOfCodeConvertible {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "func \(name)(\(parameterList)) throws {",
            nestedLines:     linesOfCodeForBody(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForBody(at indentation: Indentation) -> [LineOfCode] {
        return [indentation.apply(toLineOfCode: "let parameters = [XMLElement]()")]
            + linesOfCodeForParameters(at: indentation)
            + linesOfCodeForSend(at: indentation)
    }

    private func linesOfCodeForParameters(at indentation: Indentation) -> [LineOfCode] {
        return input.parts.flatMap(linesOfCodeForParameter(part:)).map(indentation.apply(toLineOfCode:))
    }

    private func linesOfCodeForParameter(part: Message.Part) -> [LineOfCode] {
        let property = part.name.localName.toSwiftPropertyName()
        return [
            "let \(property)Node = XMLElement(prefix: \"ns0\", localName: \"\(part.name.localName)\", uri: \"\(part.name.uri)\")",
            "\(property)Node.addNamespace(XMLNode.namespace(withName: \"ns0\", stringValue: \"\(part.name.uri)\") as! XMLNode)",
            "try \(property).serialize(\(property)Node)",
            "parameters.append(\(property)Node)"
        ]
    }

    func linesOfCodeForSend(at indentation: Indentation) -> [LineOfCode] {
        return [
            "try send(parameters: parameters, output: { body in",
            "    let outputNode = body.elements(forLocalName: \"\(output.name.localName)\", uri: \"\(output.name.uri)\").first!",
            "    output(try \(output.name.localName.toSwiftTypeName())(deserialize: outputNode))",
            "})"
            ].map(indentation.apply(toLineOfCode:))
    }

    private var parameterList: String {
        return parameters.map { $0.toSwiftCode() }.joined(separator: ", ")
    }

    var parameters: [SwiftParameter] {
        return input.parts.map {
            SwiftParameter(name: $0.name.localName.toSwiftPropertyName(), type: .identifier($0.element.localName.toSwiftTypeName()))
            }
            + [SwiftParameter(name: "output", type: .identifier("() -> ()"))]
    }
}

