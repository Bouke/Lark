import SchemaParser

protocol SwiftCodeConvertible {
    func toSwiftCode(indentedBy indentChars: String) -> SwiftCode
}

protocol LinesOfCodeConvertible: SwiftCodeConvertible {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode]
}

extension LinesOfCodeConvertible {
    func toSwiftCode(indentedBy indentChars: String = "    ") -> SwiftCode {
        let indentation = Indentation(chars: indentChars)
        let linesOfCode = toLinesOfCode(at: indentation)
        return linesOfCode.joined(separator: "\n")
    }
}

struct SwiftCodeGenerator {
    /// This method is used when only one Swift file is being generated.
    static func generateCode(for types: [SwiftCodeConvertible], _ clients: [SwiftClientClass]) -> String {
        return [
            preamble,
            "//",
            "// MARK: - SOAP Structures",
            "//",
            types.map { $0.toSwiftCode(indentedBy: "    ") }.joined(separator: "\n\n"),
            "",
            "//",
            "// MARK: - SOAP Client",
            "//",
            clients.map { $0.toSwiftCode(indentedBy: "    ") }.joined(separator: "\n\n"),
            ""].joined(separator: "\n")
    }

    private static let preamble = [
        "// This file was generated by Lark. https://github.com/Bouke/Lark",
        "",
        "import Foundation",
        "import LarkRuntime",
        ""].joined(separator: "\n")
}


// MARK: - Implementation

typealias SwiftCode = String
typealias LineOfCode = SwiftCode

struct Indentation {
    private let chars: String
    private let level: Int
    private let value: String

    init(chars: String, level: Int = 0) {
        precondition(level >= 0)
        self.chars = chars
        self.level = level
        self.value = String(repeating: chars, count: level)
    }

    func apply(toLineOfCode lineOfCode: LineOfCode) -> LineOfCode {
        return value + lineOfCode
    }

    func apply(toFirstLine firstLine: LineOfCode,
               nestedLines: [LineOfCode],
               andLastLine lastLine: LineOfCode) -> [LineOfCode] {
        return apply(
            toFirstLine: firstLine,
            nestedLines: { indentation in nestedLines.map { line in indentation.apply(toLineOfCode: line) } },
            andLastLine: lastLine)
    }

    func apply(toFirstLine firstLine: LineOfCode,
               nestedLines generateNestedLines: (Indentation) -> [LineOfCode],
               andLastLine lastLine: LineOfCode) -> [LineOfCode] {
        let first  = apply(toLineOfCode: firstLine)
        let middle = generateNestedLines(self.increased())
        let last   = apply(toLineOfCode: lastLine)
        return [first] + middle + [last]
    }

    private func increased() -> Indentation {
        return Indentation(chars: chars, level: level + 1)
    }
}


// MARK:- SOAP Types

extension SwiftTypeClass {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        let baseType = base?.name ?? "XMLDeserializable"
        return indentation.apply(
            toFirstLine: "class \(name): \(baseType) {",
            nestedLines:      linesOfCodeForMembers(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForMembers(at indentation: Indentation) -> [LineOfCode] {
        return linesOfCodeForProperties(at: indentation)
            + initializer(at: indentation)
            + deserializer(at: indentation)
            + serializer(at: indentation)
            + linesOfCodeForNestedClasses(at: indentation)
            + members.flatMap { $0.toLinesOfCode(at: indentation) }
    }

    private func initializer(at indentation: Indentation) -> [LineOfCode] {
        let superInit: [LineOfCode] = base.map { _ in
            let arguments = inheritedProperties
                .map { "\($0.name): \($0.name)" }
                .joined(separator: ", ")
            return ["super.init(\(arguments))"]
        } ?? []

        let override = properties.count == 0 && base != nil ? "override " : ""

        let signature = (inheritedProperties + properties)
            .map { "\($0.name): \($0.type.toSwiftCode())" }
            .joined(separator: ", ")

        return indentation.apply(
            toFirstLine: "\(override)init(\(signature)) {",
            nestedLines:
                properties.map { property in
                    "self.\(property.name) = \(property.name)"
                } + superInit,
            andLastLine: "}")
    }

    private func deserializer(at indentation: Indentation) -> [LineOfCode] {
        let superInit: [LineOfCode] = base.map { _ in ["try super.init(deserialize: element)"] } ?? []
        return indentation.apply(
            toFirstLine: "required init(deserialize element: XMLElement) throws {",
            nestedLines:
                properties.map { property in
                    let element = property.element.name
                    switch property.type {
                    case let .identifier(identifier):
                        return "self.\(property.name) = try \(identifier)(deserialize: element.elements(forLocalName: \"\(element.localName)\", uri: \"\(element.uri)\").first!)"
                    case let .optional(.identifier(identifier)):
                        return "self.\(property.name) = try element.elements(forLocalName: \"\(element.localName)\", uri: \"\(element.uri)\").first.map(\(identifier).init(deserialize:))"
                    case let .array(.identifier(identifier)):
                        return "self.\(property.name) = try element.elements(forLocalName: \"\(element.localName)\", uri: \"\(element.uri)\").map(\(identifier).init(deserialize:))"
                    default:
                        fatalError("Type \(property.type) not supported")
                    }
                } + superInit,
            andLastLine: "}")
    }

    private func serializer(at indentation: Indentation) -> [LineOfCode] {
        let override = base.map { _ in "override " } ?? ""
        let superSerialize: [LineOfCode] = base.map { _ in ["try super.serialize(element)"] } ?? []
        return indentation.apply(
            toFirstLine: "\(override)func serialize(_ element: XMLElement) throws {",
            nestedLines:
            properties.flatMap { property -> [LineOfCode] in
                let element = property.element.name
                switch property.type {
                case .identifier:
                    return [
                        "let \(property.name)Node = try element.createElement(localName: \"\(element.localName)\", uri: \"\(element.uri)\")",
                        "element.addChild(\(property.name)Node)",
                        "try \(property.name).serialize(\(property.name)Node)",
                    ]
                case .optional(.identifier):
                    return [
                        "if let \(property.name) = \(property.name) {",
                        "    let \(property.name)Node = try element.createElement(localName: \"\(element.localName)\", uri: \"\(element.uri)\")",
                        "    element.addChild(\(property.name)Node)",
                        "    try \(property.name).serialize(\(property.name)Node)",
                        "}"
                    ]
                case .array(.identifier):
                    return [
                        "for item in \(property.name) {",
                        "    let itemNode = try element.createElement(localName: \"\(element.localName)\", uri: \"\(element.uri)\")",
                        "    element.addChild(itemNode)",
                        "    try item.serialize(itemNode)",
                        "}"
                    ]
                default:
                    fatalError("Type \(property.type) not supported")
                }
            } + superSerialize,
            andLastLine: "}")
    }

    private func linesOfCodeForProperties(at indentation: Indentation) -> [LineOfCode] {
        return sortedProperties.map { property in
            let propertyCode = property.toLineOfCode()
            return indentation.apply(toLineOfCode: propertyCode)
        }
    }

    private var inheritedProperties: [SwiftProperty] {
        return (base?.inheritedProperties ?? []) + (base?.properties ?? [])
    }

    private var sortedProperties: [SwiftProperty] {
        return properties.sorted { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        }
    }

    private func linesOfCodeForNestedClasses(at indentation: Indentation) -> [LineOfCode] {
        return sortedNestedTypes.flatMap { $0.toLinesOfCode(at: indentation) }
    }

    private var sortedNestedTypes: [SwiftMetaType] {
        return nestedTypes.sorted(by: { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        })
    }
}

extension SwiftType {
    func toSwiftCode() -> SwiftCode {
        switch self {
        case let .identifier(name): return name
        case let .optional(type): return "\(type.toSwiftCode())?"
        case let .array(type): return "[\(type.toSwiftCode())]"
        }
    }
}

extension SwiftProperty {
    func toLineOfCode() -> LineOfCode {
        return "let \(name): \(type.toSwiftCode())"
    }
}

extension SwiftParameter {
    func toSwiftCode() -> SwiftCode {
        return "\(name): \(type.toSwiftCode())"
    }
}

extension SwiftEnum {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "enum \(name): \(rawType.toSwiftCode()), XMLSerializable, XMLDeserializable {",
            nestedLines:      linesOfCodeForBody(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForBody(at indentation: Indentation) -> [LineOfCode] {
        return linesOfCodeForCases(at: indentation) +
            linesOfCodeForDeserializer(at: indentation) +
            linesOfCodeForSerializer(at: indentation)
    }

    private func linesOfCodeForCases(at indentation: Indentation) -> [LineOfCode] {
        return sortedCases.map { (name, rawValue) in
            return indentation.apply(toLineOfCode: "case \(name) = \"\(rawValue)\"")
        }
    }

    private var sortedCases: [(String, String)] {
        return cases.sorted(by: { return $0.key < $1.key } )
    }

    private func linesOfCodeForDeserializer(at indentation: Indentation) -> [LineOfCode] {
        // TODO: no force unwraps
        return indentation.apply(
            toFirstLine: "init(deserialize element: XMLElement) throws {",
            nestedLines: ["self.init(rawValue: element.stringValue!)!"],
            andLastLine: "}")
    }

    private func linesOfCodeForSerializer(at indentation: Indentation) -> [LineOfCode] {
        // TODO: no force unwraps
        return indentation.apply(
            toFirstLine: "func serialize(_ element: XMLElement) throws {",
            nestedLines: ["element.stringValue = self.rawValue"],
            andLastLine: "}")
    }
}

// MARK:- SOAP Client

extension SwiftClientClass {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "class \(name): Client {",
            nestedLines:      linesOfCodeForMembers(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForMembers(at indentation: Indentation) -> [LineOfCode] {
        return rule2initializer(at: indentation)
            + initializer(at: indentation)
            + methods.flatMap { $0.toLinesOfCode(at: indentation) }
    }

    /// Per "Rule 2", we need to provide our own implementation of the designated
    /// initializer to inherit the convenience initializers. So while this 
    /// initializer does nothing; it fullfills the requirements of Rule 2.
    private func rule2initializer(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "override init(channel: Channel) {",
            nestedLines: [
                "super.init(channel: channel)"
            ],
            andLastLine: "}")
    }

    private func initializer(at indentation: Indentation) -> [LineOfCode] {
        guard case let .soap11(endpoint) = port.address else {
            fatalError("Expected SOAP 1.1 port")
        }
        return indentation.apply(
            toFirstLine: "convenience init() {",
            nestedLines: [
                "self.init(endpoint: URL(string: \"\(endpoint)\")!)"
            ],
            andLastLine: "}")
    }
}

extension ServiceMethod: LinesOfCodeConvertible {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "func \(name)(_ parameter: \(input.type)) throws -> \(output.type) {",
            nestedLines: [
                "var parameters = [XMLElement]()",
                "let parameterNode = XMLElement(prefix: \"ns0\", localName: \"\(input.element.localName)\", uri: \"\(input.element.uri)\")",
                "parameterNode.addNamespace(XMLNode.namespace(withName: \"ns0\", stringValue: \"\(input.element.uri)\") as! XMLNode)",
                "try parameter.serialize(parameterNode)",
                "parameters.append(parameterNode)",
                "let body = try send(action: URL(string: \"\(action?.absoluteString ?? "")\"), parameters: parameters)",
                "let outputNode = body.elements(forLocalName: \"\(output.element.localName)\", uri: \"\(output.element.uri)\").first!",
                "return try \(output.type)(deserialize: outputNode)"
            ],
            andLastLine: "}")
    }

//    private func linesOfCodeForBody(at indentation: Indentation) -> [LineOfCode] {
//        return [indentation.apply(toLineOfCode: )]
//            + linesOfCodeForParameters(at: indentation)
//            + linesOfCodeForSend(at: indentation)
//    }
//
//    private func linesOfCodeForParameters(at indentation: Indentation) -> [LineOfCode] {
//        return input.parts.flatMap(linesOfCodeForParameter(part:)).map(indentation.apply(toLineOfCode:))
//    }
//
//    private func linesOfCodeForParameter(part: Message.Part) -> [LineOfCode] {
//        var property = part.name.localName.toSwiftPropertyName()
//        // todo: generate proper unique names for scope
//        if property == "parameters" {
//            property = "params"
//        }
//        return [
//            "let \(property)Node = XMLElement(prefix: \"ns0\", localName: \"\(part.element.localName)\", uri: \"\(part.element.uri)\")",
//            "\(property)Node.addNamespace(XMLNode.namespace(withName: \"ns0\", stringValue: \"\(part.element.uri)\") as! XMLNode)",
//            "try \(property).serialize(\(property)Node)",
//            "parameters.append(\(property)Node)"
//        ]
//    }
//
//    func linesOfCodeForSend(at indentation: Indentation) -> [LineOfCode] {
//        return [
//            "let body = try send(action: URL(string: \"\(action.absoluteString)\")!, parameters: parameters)",
//            "let outputNode = body.elements(forLocalName: \"\(output.element.localName)\", uri: \"\(output.element.uri)\").first!",
//            "return try \(output.type)(deserialize: outputNode)"
//        ].map(indentation.apply(toLineOfCode:))
//    }
//
//    private var parameterList: String {
//        return parameters.map { $0.toSwiftCode() }.joined(separator: ", ")
//    }
//
//    var parameters: [SwiftParameter] {
//        var property = input.element.localName.toSwiftPropertyName()
//        if property == "parameters" {
//            property = "params"
//        }
//        return [SwiftParameter(name: property, type: .identifier(input.type))]
//    }
}

